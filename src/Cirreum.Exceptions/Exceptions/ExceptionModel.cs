namespace Cirreum.Exceptions;

using System.Collections.Generic;
using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization;

/// <summary>
/// A ProblemDetail implementation with an explicit property for exposing
/// failures [<see cref="FailureModel"/>] (e.g., Validation Failures or any other Problem Detail extensions).
/// </summary>
public class ExceptionModel {

	/// <summary>
	/// Constructor
	/// </summary>
	public ExceptionModel() {
		this.Failures = [];
	}

	/// <summary>
	/// A URI reference [RFC3986] that identifies the
	/// problem type. This specification encourages that, when
	/// dereferenced, it provide human-readable documentation for the
	/// problem type (e.g., using HTML [W3C.REC-html5-20141028]). When
	/// this member is not present, its value is assumed to be
	/// "about:blank".
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-5)]
	public string? Type { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. Default: "Internal Server Error"
	/// </summary>
	/// <remarks>
	/// It SHOULD NOT change from occurrence to occurrence of the
	/// problem, except for purposes of localization(e.g., using
	/// proactive content negotiation; see[RFC7231], Section 3.4)
	/// </remarks>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	public string? Title { get; set; }

	/// <summary>
	/// The HTTP status code ([RFC7231], Section 6) generated by the origin server
	/// for this occurrence of the problem. Default: <see cref="HttpStatusCode.InternalServerError"/>
	/// </summary>
	[JsonIgnore]
	public HttpStatusCode StatusCode { get; set; } = HttpStatusCode.InternalServerError;

	/// <summary>
	/// The HTTP status code ([RFC7231], Section 6) generated by the origin server
	/// for this occurrence of the problem. Default: <see cref="HttpStatusCode.InternalServerError"/>
	/// </summary>
	[JsonPropertyOrder(-3)]
	public int Status { get { return (int)this.StatusCode; } set { this.StatusCode = (HttpStatusCode)value; } }

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	/// <remarks>
	/// Ensure to not leak sensitive information.
	/// </remarks>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	public string? Detail { get; set; }

	/// <summary>
	/// A URI reference that identifies the specific 
	/// occurrence of the problem. It may or may not yield further
	/// information if dereferenced.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	public string? Instance { get; set; }

	/// <summary>
	/// Optional collection of other failures associated with the exception.
	/// </summary>
	public IEnumerable<FailureModel> Failures { get; set; } = [];

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members.
	/// Extension members appear in the same namespace as other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation
	/// of the Input \ Output formatters. In particular, complex types or collection types may not
	/// round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, JsonElement>? Extensions { get; set; }

}